<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>rust-training-aug19</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="preface.html">Preface</a></li><li><a href="installation_win.html"><strong aria-hidden="true">1.</strong> Installation (Windows)</a></li><li><a href="anatomy.html"><strong aria-hidden="true">2.</strong> anatomy</a></li><li><a href="data_types.html"><strong aria-hidden="true">3.</strong> data types</a></li><li><a href="error_handling.html"><strong aria-hidden="true">4.</strong> error handling</a></li><li><a href="traits.html"><strong aria-hidden="true">5.</strong> traits</a></li><li><a href="external_dependencies.html"><strong aria-hidden="true">6.</strong> external dependencies</a></li><li><a href="enums.html"><strong aria-hidden="true">7.</strong> Enums and algebraic data types</a></li><li><a href="todo.html"><strong aria-hidden="true">8.</strong> borrow checker, scopes, raii, clone</a></li><li><a href="todo.html"><strong aria-hidden="true">9.</strong> code organization, modules</a></li><li><a href="control.html"><strong aria-hidden="true">10.</strong> Control Structures</a></li><li><a href="iterators.html"><strong aria-hidden="true">11.</strong> Iterators</a></li><li><a href="todo.html"><strong aria-hidden="true">12.</strong> rayon</a></li><li><a href="todo.html"><strong aria-hidden="true">13.</strong> Cross compiling for the linux arm target</a></li><li><a href="todo.html"><strong aria-hidden="true">14.</strong> FFI, calling C libraries, using unsafe Rust, and wrapper generation from C headers</a></li><li><a href="todo.html"><strong aria-hidden="true">15.</strong> type states</a></li><li><a href="todo.html"><strong aria-hidden="true">16.</strong> Generics, using strong types to avoid C and C++ weaknesses</a></li><li><a href="todo.html"><strong aria-hidden="true">17.</strong> networking, http? mqtt, changing states</a></li><li><a href="todo.html"><strong aria-hidden="true">18.</strong> macros struct op on top of our options struct</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">rust-training-aug19</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>Rust is a safe, typed, compiled, general programming language.</p>
<ul>
<li>Safe is a very overloaded term in Rust, but by default Rust uses static analysis at compile time to enforces rules about memory usage. Traditionally, managing your own memory in languages like C++ and Objective-C has been very tedious and still error prone. Rust's solution to this, The borrow checker, is probably the defining feature of the Rust language. You have to spend a little more time annotating your code to say who owns a variable at any given time with the borrow checker keeping you honest the whole time. It's like pair programming with a friend.</li>
<li>Typed - As opposed to languages like javascript, Rust forces you to state the types of variables going into and out of functions. This helps you organize your intentions and acts much like a set of tests to make sure your code makes sense.</li>
<li>Compiled - Rust has to do all its work up front at compile time and turns into a binary immediately. Compiles can be slow sometimes, but our code runs fast, and anywhere, as a result. <a href="https://xkcd.com/303/">obligatory xkcd</a> </li>
<li>General. Much like most modern languages these days it's not strictly functional or object oriented (OO). Further it can be deployed almost anywhere. We can write backend server code, embedded microcontroller applications, and with WASM, even front end web applications, cloud functions and blockchains.</li>
</ul>
<p>Our audience are professional developers cross training from languages such as C, C++, Python and Golang.</p>
<p>We will build on and link heavily to the <a href="https://doc.rust-lang.org/book/">Rust Book</a> and <a href="https://doc.rust-lang.org/std/">Standard Library documentation</a> but if you ever get lost you should take it upon yourself to head back there to find clarification. A huge part of why Rust is so powerful is its evolving, responsive, tested, up to date and clear documentation. Many thanks to the tireless authors of those resources. </p>
<h1><a class="header" href="#installing-rust-on-windows" id="installing-rust-on-windows">Installing Rust on Windows</a></h1>
<p>This guide will cover:</p>
<ul>
<li><a href="installation_win.html#installing-rust-with-rustup">Installing Rust with Rustup</a></li>
<li><a href="installation_win.html#configuring-gvim-8x-for-rust-with-the-rls">Configuring GVim 8.x for Rust</a></li>
<li><a href="installation_win.html#configuring-vs-code-for-rust-with-the-rls">Configuring VS Code for Rust</a></li>
</ul>
<h2><a class="header" href="#installing-rust-with-rustup" id="installing-rust-with-rustup">Installing Rust with Rustup</a></h2>
<ol>
<li>
<p>Visit <a href="https://rustup.rs">rustup.rs</a>, download, and then run rustup-init.exe</p>
<p><img src="./images/install/rustup.png" alt="Rustup website" /></p>
</li>
<li>
<p>Make sure you have the dependencies met. The Rust installation includes the Rust compiler, but Rust uses the system linker to create the final executables and link to system shared libraries (DLLs). So, we have to make sure a usable linker and system libraries are installed.</p>
<ol>
<li>If you already have one of the listed Visual Studio versions installed with C++ build tools, the dependencies should be met already
<ol>
<li>If later you get an error about &quot;Link.exe&quot;, follow step 2</li>
</ol>
</li>
<li>Otherwise, install these:
<ol>
<li><a href="https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk">Windows 10 SDK</a></li>
<li><a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwj647KSzY_kAhXCPn0KHV5nC4IQFjAAegQIAhAB&amp;url=https%3A%2F%2Fgo.microsoft.com%2Ffwlink%2F%3FLinkId%3D691126&amp;usg=AOvVaw0geDw_h-TSCfzTMvYE2ZOw">Microsoft Visual C++ build tools</a></li>
</ol>
</li>
</ol>
<p><img src="./images/install/rustup2.png" alt="Rustup deps" /></p>
</li>
<li>
<p>Press <code>1</code> and then <code>enter</code> to proceed with the installation</p>
<p><img src="./images/install/rustup3.png" alt="Proceed with install" /></p>
</li>
<li>
<p>Once the installation is complete, the below message should show. Press <code>enter</code> to close the window.</p>
<p><img src="./images/install/rustup4.png" alt="Installation finished" /></p>
</li>
<li>
<p>Test the rustup installation:</p>
<ol>
<li>Open a new command prompt window</li>
<li>Run the command <code>rustup</code>. The command should show help information.</li>
</ol>
<p><img src="./images/install/rustuphelp.png" alt="Rustup help" /></p>
<ol start="3">
<li>If the <code>rustup</code> command fails, add <code>%USERPROFILE%\.cargo\bin</code> to your <code>PATH</code> environment variable.</li>
</ol>
</li>
<li>
<p>Install the Rust Language Server (RLS):</p>
<ol>
<li>Open a command prompt window (you can reuse the same window)</li>
<li>Run the command <code>rustup component add rls</code>. The command should download and install the RLS.</li>
</ol>
<p><img src="./images/install/rustup5.png" alt="Installing Rust language server" /></p>
<ol start="3">
<li>Install the rustfmt component by running the command <code>rustup component add rustfmt</code></li>
</ol>
<p><img src="./images/install/rustupfmt.png" alt="Installing Rust language server" /></p>
</li>
</ol>
<h2><a class="header" href="#test-out-the-rust-installation" id="test-out-the-rust-installation">Test out the Rust installation</a></h2>
<ol>
<li>
<p>Open a command prompt window</p>
</li>
<li>
<p>Navigate to a directory wherein we will create a test project.</p>
</li>
<li>
<p>Run the command <code>cargo new --bin hellorust</code> to create a new project named &quot;hellorust&quot;.</p>
<ul>
<li>Cargo is the Rust build system and package manager.</li>
<li>The <code>--bin</code> argument means we are creating a binary project that builds an executable.</li>
<li>We can also create a crate (Rust's name for libraries) by passing the <code>--lib</code> argument.</li>
<li>The <code>cargo new</code> command creates a new directory named &quot;hellorust&quot; and creates the default Rust project directory structure</li>
</ul>
<pre><code class="language-text">hellorust
- src
  - main.rs
- Cargo.toml
- Cargo.lock
- target
</code></pre>
<ul>
<li>The <code>src</code> directory contains the project's Rust source code files</li>
<li><code>Cargo.toml</code> contains the project configuration used by Cargo to build the project. This file includes dependencies, build configurations, metadata, and more.</li>
<li><code>Cargo.lock</code> is generated by Cargo and contains the &quot;locked&quot; or exact versions of the dependencies used to build your project. This file should not be edited.</li>
<li>The <code>target</code> directory contains the build products generate by Cargo. For a binary project, the exectuable will usually be at <code>target\debug\hellorust</code> (or <code>target\release\hellorust</code>).</li>
</ul>
</li>
<li>
<p>Navigate into the &quot;hellorust&quot; directory</p>
</li>
<li>
<p>Build the project by running the command <code>cargo build</code></p>
<ul>
<li>By default, Cargo will build the project in the debug configuration</li>
<li>You can build the release configuration with the command: <code>cargo build --release</code></li>
<li>If you see an error about &quot;Link.exe&quot;, make sure the installation dependencies are met (detailed in the installation section above)</li>
</ul>
<p><img src="./images/install/cargobuild.png" alt="Running Cargo build" /></p>
</li>
<li>
<p>Run the project with the command: <code>cargo run</code></p>
<ul>
<li>This command will also build the project if your build is out-of-date</li>
<li>By default, <code>cargo run</code> builds and runs the debug configuration. You can run the release configuration with: <code>cargo run --release</code>.</li>
<li>Arguments after <code>cargo run</code> are passed to Cargo (for example the <code>--release</code> argument). If you want to pass arguments to your program, put them after a <code>--</code> delimiter. For example: <code>cargo run --release -- my args here</code></li>
</ul>
<p><img src="./images/install/cargorun.png" alt="Running Cargo project" /></p>
</li>
<li>
<p>Many Rust projects include automated tests. Cargo can run these tests with the command <code>cargo test</code> (<code>--release</code> works here too). To try out Rust tests, we can modify <code>src/main.rs</code> to contain a simple failing test:</p>
<ol>
<li>Modify <code>main.rs</code>:</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}

#[test]
fn failing_test() {
    assert!(2 + 2 == 5);
}
</code></pre></pre>
<ol>
<li>Run the tests with <code>cargo test</code></li>
</ol>
<p><img src="./images/install/cargotest.png" alt="Using Cargo to run tests" /></p>
</li>
</ol>
<h2><a class="header" href="#configuring-gvim-8x-for-rust-with-the-rls" id="configuring-gvim-8x-for-rust-with-the-rls">Configuring GVim 8.x for Rust with the RLS</a></h2>
<p>The steps below configure GVim 8.x on Windows to support Rust and use the Rust Language Server (RLS) for autocompletion.</p>
<ol>
<li>
<p>Make sure you have a working Git installation. (<a href="https://git-scm.com/download/win">Download Here for Windows</a>)</p>
</li>
<li>
<p>Visit <a href="https://rls.booyaa.wtf">https://rls.booyaa.wtf</a> and follow the steps for your preferred Vim package management strategy.</p>
</li>
<li>
<p>Modify your vimrc to include the below snippet. The guide linked in the previous step is still configured to use the Rust nightly build, since the RLS used to only be available in the nightly builds. RLS is now available in stable, and we installed stable Rust (the default). The below snippet should replace the one from the linked guide, and changes the 'cmd' to use stable instead of nightly.</p>
<pre><code class="language-text"> if executable('rls')
     au User lsp_setup call lsp#register_server({
         \ 'name': 'rls',
         \ 'cmd': {server_info-&gt;['rustup', 'run', 'stable', 'rls']},
         \ 'whitelist': ['rust'],
         \ })
 endif
</code></pre>
</li>
<li>
<p>Make sure <code>filetype plugin indent on</code> and <code>syntax enable</code> are also in your vimrc</p>
</li>
<li>
<p>Restart GVim or reload your vimrc</p>
</li>
<li>
<p>Open a Rust file and test our autocompletion (for example start typing <code>use std::</code>)</p>
<p><img src="./images/install/gvimrls.png" alt="GVim Rust autocompletion" /></p>
</li>
</ol>
<h2><a class="header" href="#configuring-vs-code-for-rust-with-the-rls" id="configuring-vs-code-for-rust-with-the-rls">Configuring VS Code for Rust with the RLS</a></h2>
<p>The steps below configure VS Code on Windows to support Rust and use the Rust Language Server (RLS) for autocompletion and incremental compilation to display warnings and errors.</p>
<ol>
<li>
<p>Install the Rust (rls) extension by user 'rust-lang' in VS Code. There are several other plugins, but this one is the most maintained.</p>
</li>
<li>
<p>Reload the window in VS Code, or restart VS Code</p>
</li>
<li>
<p>If you see an error message that the RLS could not be started or that the extension could not find rustup, then you will have to configure VS Code's path for rustup:</p>
<ol>
<li>
<p>Open VS Code preferences and navigate to the Rust extension preferences</p>
</li>
<li>
<p>Modify the rustup path to use an absolute path to your installation: <code>C:\Users\&lt;username&gt;\.cargo\bin\rustup</code></p>
<p><img src="./images/install/vscode_rust.png" alt="VS Code rustup path" /></p>
</li>
<li>
<p>Reload the window in VS Code, or restart VS Code</p>
</li>
<li>
<p>You may see a prompt in the lower-right to install the RLS. If so, click yes.</p>
</li>
</ol>
</li>
<li>
<p>Open a Rust file and test out the RLS:</p>
<ol>
<li>Try autocompletion (for example start typing <code>use std::</code>) at the top of a file</li>
<li>Try the incremental compilation (for example <code>println!(&quot;Hello, world!&quot;) blah blah 42 42</code> should show an inline error)</li>
</ol>
<p><img src="./images/install/vscode_rust2.png" alt="VS Code Rust autocompletion and incremental compilation" /></p>
</li>
</ol>
<h1><a class="header" href="#anatomy-of-rust-program-and-some-workflow" id="anatomy-of-rust-program-and-some-workflow">anatomy of Rust program and some workflow</a></h1>
<p>We’ve got a few tools to get to know</p>
<ul>
<li>rustup - manage tools and versions of toolchains</li>
<li>rustc - rust compiler</li>
<li>cargo - manage modules locally and remotely and drives rustc</li>
</ul>
<p>Open a terminal and create a new package with <code>cargo new training</code> and go to that directory with <code>cd training</code></p>
<p>Now we have a Cargo.toml which defines our project, not unlike a package.json if you're familiar with Node.js, it defines dependencies we're using and other project information:</p>
<pre><code class="language-toml">[package]
name = &quot;training&quot;
version = &quot;0.1.0&quot;
authors = [&quot;First Last&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<p>In src folder we have main.rs, a Rust file. In this case it generated a simple hello world. </p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>We're starting to get some syntax for you. Notice functions are denoted <code>fn</code>, we use semicolons to end expressions, and the exclamation after <code>println!()</code> means that is a function-like macro. We'll talk more about <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">macros</a> later.</p>
<p>Generally we'll interact with the compiler via Cargo. Cargo drives the rustc compiler and linker all under the hood. We can <code>cargo build</code> or better yet <code>cargo run</code> and save ourselves a step:</p>
<pre><code class="language-bash">$ cargo run
   Compiling training v0.1.0 (/Users/firstlast/training)
    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
     Running `/Users/firstlast/.cache/target/debug/training`
Hello, world!
</code></pre>
<p>The default build directory is target, and by default we got a debug build</p>
<pre><code class="language-bash">$ ls target/debug/
build		examples	native		training.d
deps		incremental	training	training.dSYM
</code></pre>
<p>Note, we could run or debug that built asset directly:</p>
<pre><code class="language-bash">./target/debug/training
Hello, world!
</code></pre>
<p>Also note, we could have compiled this simple file with the rustc compiler directly</p>
<pre><code class="language-bash">$ rustc src/main.rs
$ ./main
Hello, world!
</code></pre>
<p>However in practice almost no projects are single files require merging multiple modules from within our project and without and thus Cargo is THE way we interact with Rust.</p>
<h1><a class="header" href="#primitive-data-types" id="primitive-data-types">primitive data types</a></h1>
<p>We’ve got all the datatypes you would expect but you might want to glance through the Rust book <a href="https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html">chapter on variables, functions, and control flow</a> just to update your mental models to Rust notation</p>
<p>We have signed and unsigned scalar types like u32 and i32 and we've got Strings. Variables are instantiated with let syntax, and notably are immutable by default.</p>
<p>The top of the <a href="https://doc.rust-lang.org/std/">Rust standard library page</a> has a search box. Entering String there we find <a href="https://doc.rust-lang.org/std/string/struct.String.html#method.from">std::string::String</a> with a bunch of example usage right there for us. You can edit those examples and run them right in your browser to confirm your understanding and even click the [src] link in the upper right corner and be taken straight to the Rust implementation.</p>
<blockquote>
<p>While you totally can thrash around on stack overflow, and we all do, there really is an authoritative source that you should check first.</p>
</blockquote>
<p>From that example we have our String constructor:</p>
<pre><pre class="playpen"><code class="language-rust no_run">fn main() {
    let input_path = String::from(&quot;cat.jpg&quot;);
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>First, note we don’t need to import anything (we call it <code>use</code>) to use this type. A portion of the standard library is in our namespace automatically, which we call the <a href="https://doc.rust-lang.org/std/prelude/index.html">prelude</a>. Basically Rust puts <code>use std::prelude::v1::*;</code> at the top of your file and you get access to those members. By no means is everything in there, but a lot is, which is what kept you from explicitly writing <code>use std::string::String</code> at the top of your file in this case.</p>
<p>Also notice we didn't have to explicitly type our variable. What Rust <em>can</em> figure it out, <em>it will</em> and so its entirely idiomatic to omit type annotations. However if you or the compiler are having trouble or getting odd type errors, start annotating some of your types like to see if you can give the compiler a hand. Its also a great way to figure out what type you actually have in case you're not sure, let the compiler (or linter) tell you.</p>
<pre><pre class="playpen"><code class="language-rust no_run">fn main() {
    let input_path = String::from(&quot;cat.jpg&quot;);
    let output_path:String = String::from(&quot;test.png&quot;);
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>So now how to print those variables to console.  In Rust our printf <code>%</code> formatting character is <code>{}</code>. Following the <code>println!()</code> documentation down the rabbit hole will send us to the <a href="https://doc.rust-lang.org/std/fmt/index.html">formatters section</a> page and we find all the formatters which you would expect like hex <code>{:x}</code>, binary <code>{:b}</code>, etc. We're going to focus on the 'empty' Display formatter <code>{}</code> for now which is a kind of a pretty printer in Rust. As long as whomever wrote our type implemented the Display pretty printer trait this will work great (cue ominous music).</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let input_path = String::from(&quot;cat.jpg&quot;);
    let output_path = String::from(&quot;test.png&quot;);
    println!(&quot;{} {}&quot;, input_path, output_path);
}
</code></pre></pre>
<p>Running this we find that we do have a Display implementation for String and pretty printing results in rather clean output in this case:</p>
<pre><code class="language-text">cat.jpg test.png
</code></pre>
<p>Objects, we call them structs, should be very familiar. You can define a new struct in any scope you like and we can name and type their members.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Opt {
    input_path: String,
    output_path: String,
}

fn main() {

    let options = Opt {
        input_path: String::from(&quot;cat.jpg&quot;),
        output_path: String::from(&quot;test.png&quot;),
    };

    println!(&quot;{} {}&quot;, options.input_path, options.output_path);
}
</code></pre></pre>
<p>Notice we access our struct members with dot notation, and there is no default new constructor or overloading in Rust. Though in practice, for functions where it makes sense many developers will offer and occasionally make their struct private to require the usage of a new or other constructor. So note, <code>String::new()</code> totally exists and would have made you an empty string.</p>
<p>Lets start modularizing our main by putting our options creation in a function. Function syntax is just like we see in the main function, but can return an expression from a function by leaving off the semicolon and annotating the return type:</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Opt {
    input_path: String,
    output_path: String,
}

fn options() -&gt; Opt {

    let options = Opt {
        input_path: String::from(&quot;cat.jpg&quot;),
        output_path: String::from(&quot;test.png&quot;),
    };
    return options;
}

fn main() {
    let options = options();
    println!(&quot;{} {}&quot;, options.input_path, options.output_path);
}
</code></pre></pre>
<p>We use semicolons to end expressions. We prefer to leave off semicolons in order to implicitly return the expression saving us the temporary variable like so:</p>
<pre><code class="language-rust ignore no_run">fn options() -&gt; Opt {

    Opt {
        input_path: String::from(&quot;cat.jpg&quot;),
        output_path: String::from(&quot;test.png&quot;),
    }
}
</code></pre>
<p>But what if our options creation could fail? Lets talk about error handling in rust.</p>
<h1><a class="header" href="#options-and-results" id="options-and-results">options and results</a></h1>
<p>Let's take our config options from the command line with runtime args instead of hard coding it at compile time. Search the standard library for <a href="https://doc.rust-lang.org/std/env/fn.args.html">args</a> finds args come in as a iterator of a collection. We'll talk about iterators later, but for now we can for loop over them, or get the <code>nth()</code> value. Just like C command line args the 0th argument is the name of the binary and the rest are your arguments. </p>
<pre><code class="language-rust ignore no_run">use std::env; // explicit use (import) finally

fn options() -&gt; Opt {

    Opt {
        input_path: env::args().nth(1).unwrap(),
        output_path: env::args().nth(2).unwrap(),
    }
}
</code></pre>
<p>And then note you can pass args around cargo to the binary were trying to run like:</p>
<pre><code class="language-bash">$ cargo run -- cat.jpg test.png
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running `target/debug/training cat.jpg test.png `
target/debug/training
cat.jpg
test.png
</code></pre>
<p>So what is this unwrap. The problem is the nth argument may or may not be there.. </p>
<p>We have two related types commingled in <a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">error handling</a> in Rust. </p>
<p>Rust doesn’t have exceptions, but rather the <a href="https://doc.rust-lang.org/std/result/index.html">Result type</a> which can be used to propagate either the error or the result and looks like this:</p>
<pre><code>pub enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre>
<p>And Rust doesn't have Null but rather the <a href="https://doc.rust-lang.org/std/option/enum.Option.html">Option type</a> which can be used to propagate either the value (Some), or the lack of one (None)</p>
<pre><code>pub enum Option&lt;T&gt; {
    None,
    Some(T),
}
</code></pre>
<p>Were going to skip Result here, as our <code>nth()</code> method returns an Option, but they’re very similar in how they’re handled as they’re both implemented as enums. We basically have three possibilities for dealing with both:</p>
<h2><a class="header" href="#option-1-panic-unwrap-and-expect" id="option-1-panic-unwrap-and-expect">Option 1, panic! unwrap and expect</a></h2>
<p>There <em>is</em> a minimal runtime in Rust, which means if were not careful we can and will blow up at runtime. This is called a panic and is handled in the panic handler, which on hosted platforms includes unwinding and backtraces. Run our program again, this time not passing arguments</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src/libcore/option.rs:347:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>Explicitly panicing like we see above may very well be an option when the error is unrecoverable anyway like in examples like this where theres nothing intelligent we can do except maybe try to print a decent error message. If the error message needs help well often well use <code>.expect(&quot;Please enter an image file as the first option to this program&quot;)</code> instead of <code>unwrap()</code> in order to further refine the message.</p>
<h2><a class="header" href="#option-2-return-it" id="option-2-return-it">Option 2, return it</a></h2>
<p>Another option is to make it someone else’s problem by simply handing the Option or Result back up the chain. </p>
<p>Theres even an exit early helper for this, the <a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator">? operator</a>. This was previously the <a href="https://doc.rust-lang.org/std/macro.try.html">try! macro</a> but that has been deprecated though you may still see it in code.</p>
<p>Our <code>nth()</code> is an Option of Some or None so lets just hand an optional back up the chain to our main function. At least this way we can decide what to do with it there.</p>
<pre><code class="language-rust ignore no_run">fn options() -&gt; Option&lt;Opt&gt; { //&lt;-return Option wrapping our Opt struct

    Some(Opt {
        input_path: env::args().nth(1).expect(&quot;first argument input file&quot;),
        output_path: env::args().nth(2).expect(&quot;second argument output file&quot;),
    })
}
</code></pre>
<p>But now we've made it main's problem to deal with. Its silly but in this case, lets just unwrap there anyway. Were back to just blowing up, but at least our deep nested library or function call isn't blowing up, our top level binary is.</p>
<pre><code class="language-rust ignore no_run">  let options = options().unwrap();
</code></pre>
<h2><a class="header" href="#option-3-handle-it" id="option-3-handle-it">option 3, handle it</a></h2>
<p>Someone has to do some control flow on this error somewhere.. Well thats actually not true, we can even return these from the main function where Rust will unwrap them behind the scenes and print the result. </p>
<p>But generally if you can do control flow on your errors you should. The way we often do that is through matching or combinators.</p>
<p>So we often will exhaustively match them with <a href="https://doc.rust-lang.org/rust-by-example/flow_control/match.html">match pattern</a> which is very similar to an exhaustive switch statement.</p>
<p>You could write it this way, revealing the options if they exist, and doing some control flow like explicitly panicing if they don’t:</p>
<pre><code class="language-rust ignore no_run">	//let options = options().unwrap();

    if let options = match options() {
        Ok(options) =&gt; options
        Err(error) =&gt; panic!(error),
    };

    println!(&quot;{} {}&quot;, options.input_path, options.output_path);
</code></pre>
<p>The Option type is actually an enum type so we lets take a full digression through enums and matching in the next section.</p>
<h1><a class="header" href="#error-handling-playground" id="error-handling-playground">error handling playground</a></h1>
<p>Its worth spending some time in the option result playground here to get your mind around all this</p>
<pre><pre class="playpen"><code class="language-rust">use std::io::ErrorKind;

fn main() {
    let first_arg = Some(&quot;cat.jpg&quot;);
    let second_arg: Option&lt;String&gt; = None;
    let good_val: Result&lt;u32, std::io::ErrorKind&gt; = Ok(22);
    let definately_error: Result&lt;u32, std::io::ErrorKind&gt; = Err(ErrorKind::Other);

    first_arg.unwrap();
    good_val.unwrap();
    //second_arg.unwrap(); // no good

    //matching is exaustive in order
    match first_arg {
        Some(val) =&gt; println!(&quot;first_arg: {}&quot;, val),
        None =&gt; {
            // you can block scope in here and do as much as needed
            println!(&quot;third_arg&quot;);
            println!(&quot;oops&quot;)
        }
    }

    // as we've said, results are similar, just two different variants
    match definately_error {
        Ok(val) =&gt; println!(&quot;cant image how we got here: {}&quot;, val),
        Err(e) =&gt; println!(&quot;{:?}&quot;, e),
    };

    // the revealing/destructuring pattern is really handy occasionally
    if let Some(val) = first_arg {
        println!(&quot;Gotem {:?}!&quot;, val);
    }

    // theres also a ton of combinators
    if good_val.is_ok() &amp;&amp; definately_error.is_err() {
        println!(&quot;some convoluted example here&quot;);
    }
}
</code></pre></pre>
<h1><a class="header" href="#traits" id="traits">traits</a></h1>
<p>But hey this seems wordy, lets just print our whole struct in one formatter.</p>
<pre><code class="language-rust ignore no_run">//println!(
//    &quot;input_path:{} output_path:{}&quot;,
//    options.input_path, options.output_path
//);
println!(&quot;{}&quot;, options);
</code></pre>
<p>Running this results in:</p>
<pre><code class="language-text">error[E0277]: `Opt` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:14:20
   |
14 |     println!(&quot;{}&quot;, options);
   |                    ^^^^^^^ `Opt` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Opt`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
   = note: required by `std::fmt::Display::fmt`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: Could not compile `training`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Thats actually really rather helpful error with a several ideas for fixing it. AND in this case if say you're offline and can't google for more information it even has another page or two of content if you run the <code>rustc --explain E0277</code> command it mentions! </p>
<blockquote>
<p>The compiler in Rust is almost always, really, actually, trying to tell you whats wrong, AND how to fix it. And if you find a case where it is not the Rust community would likely want to know how to make that error and the resulting action you should take more clear. </p>
</blockquote>
<p>For this exercise we choose to manually implement the Display trait.</p>
<p>In Rust we stress composition over inheritance using <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">traits</a>. Traits, much like header files, separate the definition from the implementation. Before we solve our actual Display problem by consuming someone else’s trait definition, lets make a convoluted example to illustrate the syntax. We'll make a silly trait that has one function so that <code>println!</code> SHOUTS our filenames.</p>
<pre><code class="language-rust ignore no_run">// create the new trait which has one function, shout
pub trait Shout {
    // we automatically get passed whatever variable function is called
    // on as the first argument to the function, we generally call it self
    fn shout(self);
}

// now implement the new trait you made
// since we're impl for Opt, self is an Opt and we have access to
// input_path and output_path
impl Shout for Opt {
    fn shout(self) {
        println!(
            &quot;{} {}&quot;,
            self.input_path.to_uppercase(),
            self.output_path.to_uppercase()
        );
    }
}
</code></pre>
<p>Now anytime this trait is in namespace, which in our case it is because it defined in this same file, it is available on all instances of Opt. Lets call it:</p>
<pre><code class="language-rust no_run ignore">//println!(&quot;{}&quot;, options);
options.shout();
</code></pre>
<p>and well should see something like</p>
<pre><code class="language-text">CAT.JPG TEST.PNG
</code></pre>
<blockquote>
<p>The separation of definition from implementation is incredibly powerful. This way if we make our trait public anyone downstream can customize our function for their architecture or edge case. This keeps Rust from amongst other things passing around huge config structs full of lifecycle callbacks and other configuration overrides.</p>
</blockquote>
<p>OK. So we can comment out our toy shout example and go back to fixing Display error. As a reminder it said</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Opt`
</code></pre>
<p>Looking in the std documentation we find <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html">Display</a> which shows us an example like below. Recall when we implement traits, the function definition was set in stone by the trait. In this case they pass us self (whatever type this method was called on, in this case Point, in our case Opt) and a second arg name f which well use the write! (just like <code>println!</code> except it sticks the output in its first argument) to print into.</p>
<p>Again we want to be able to call</p>
<pre><code class="language-rust ignore no_play">println!(&quot;{}&quot;, options);
</code></pre>
<p>My result looks like</p>
<pre><code class="language-text">(cat.jpg, test.png)
</code></pre>
<p>We're really only responsible for the returning something from the method. In the case of the Display trait that freedom largely pertains to the format string and which args we choose to print. So swap out these Point things for our Opt stuff.</p>
<pre><code class="language-rust ignore no_run">use std::fmt;

impl fmt::Display for Point {
    //Were still punting on the &amp; and &amp;mut but it doesn'nt matter here as the function definition is set in stone by the trait
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y) // notice no semicolon, were just passing the Result back
    }
}
</code></pre>
<p>And with that you've:</p>
<ul>
<li>created a new type and defined and implemented traits for it</li>
<li>implemented a trait you didn’t own.</li>
<li>but there's a third case you'll come across which is wanting to implement a trait you don't own on a type you don't own. </li>
</ul>
<blockquote>
<p>For various reasons, the compiler can't reason about these 'orphan rules' and doesn't allow them.  There are many ways around the limitation including forking the underlying crate and <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#overriding-dependencies">overriding dependencies</a> with Cargo patch functionality as well as the newtype pattern.</p>
</blockquote>
<h1><a class="header" href="#external-dependencies-cratesio" id="external-dependencies-cratesio">external dependencies, crates.io</a></h1>
<p>Lets have our code load in an image from the filesystem. Searching in the standard library for images doesn't find anything, we could take a File to binary, but lets go to the community ecosystem, <a href="https://www.crates.io">crates.io</a>. Searching there for images finds a crate image with ~1mil downloads which seems to be pretty popular. <a href="https://crates.io/crates/image">image</a> says it wants us to add it to our Cargo.toml dependencies section so lets do that.</p>
<pre><code class="language-toml">[dependencies]
image = &quot;0.22.1&quot;
</code></pre>
<p>The Cargo toml manifest version field is described here https://doc.rust-lang.org/cargo/reference/manifest.html#the-version-field where we learn Cargo uses <a href="https://semver.org">semantic versioning</a> which allows us to version and lock dependencies at the level of risk were comfortable with. From the spec:</p>
<pre><code class="language-text">Given a version number MAJOR.MINOR.PATCH, increment the:

MAJOR version when you make incompatible API changes,
MINOR version when you add functionality in a backwards compatible manner, and
PATCH version when you make backwards compatible bug fixes.
</code></pre>
<p>The <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">Cargo chapter on dependencies</a> explains more how to do this locking. The three digit version we used above is the same as a <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#caret-requirements">caret requirement</a> as if we had type <code>image = &quot;^0.22.1&quot;</code>. With this requirement Cargo is allowed to use any version it can satisfy between the range <code>&gt;=0.22.1 &lt;0.3.0</code> Semver works different below and above 1.0 with the idea that theres more breaking churn below 1.0. So for a fictional <code>image = &quot;^1.2.3&quot;</code> Cargo would be allowed to find patches <code>&gt;=1.2.3 &lt;2.0.0</code>. Refer to the spec and the book for many more clarifying examples.</p>
<p>The most restrictive version would be <code>image = &quot;= 0.22.1</code> which would not allow cargo any update capability. This can be handy for to make production code reproducible. Further along that line the resolved version state of all your dependencies (recursively) is captured in the Cargo.lock file and for binaries like ours can and should be checked into the repository. This way even if you're not locking the version explicitly you're still tracking and reviewing the upstreaming of all version changes. Finally, and outside of scope here you may also use <a href="https://doc.rust-lang.org/stable/cargo/commands/cargo-vendor.html">cargo vendor</a> to download all your dependencies locally and check them into your repository and or you may host your own <a href="https://doc.rust-lang.org/cargo/reference/registries.html">alternate registry</a> in which you only publish vetted versions.</p>
<h1><a class="header" href="#enums-matching-options" id="enums-matching-options">enums, matching, options</a></h1>
<p>So we’ve seen enums are good at constraining a type between a limited set of values and they can also hold values, like an error or a type, which makes them algebraic datatypes. Rust Enums are liked <a href="http://patshaughnessy.net/2018/3/15/how-rust-implements-tagged-unions">tagged unions for the C</a> folks but implemented in such a way that you cant hurt yourself.</p>
<p>TODO have craig go on and on about enums</p>
<p>Looking through the image documentation, we can <a href="https://docs.rs/image/0.22.1/image/fn.open.html">open an image</a>, get back a ImageResult containing a <a href="https://docs.rs/image/0.22.1/image/enum.DynamicImage.html">DynamicImage type</a>.</p>
<pre><code class="language-rust ignore no_run">//just unwrap our Result as written we have to have a value or we would have already blown up
let img = image::open(options.input_path).unwrap();
</code></pre>
<p>Then we can use any of the many handy methods including a <a href="https://docs.rs/image/0.22.1/image/enum.DynamicImage.html#method.resize">resize method</a> Authors tend to reach for enums often in constraining input to functions. Here FilterType Enum could be one of the following sampling filter:</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
pub enum FilterType {
    Nearest,
    Triangle,
    CatmullRom,
    Gaussian,
    Lanczos3,
}
#}</code></pre></pre>
<p>So something like</p>
<pre><code class="language-rust ignore no_run">//using the same variable name, called shadowing, is often even encouraged, as it means less messy temporary variables.
let img = img.resize(32, 32, FilterType::Nearest);
</code></pre>
<p>before finally saving out like:</p>
<pre><code class="language-rust ignore no_run">img.save(options.output_path).unwrap();
</code></pre>
<p>Finding a cat picture and assembling the pieces is left as a exercise for reader.</p>
<p>So obviously we'd like to take resize from the command line, which means wed like a match statement to go from a command line argument String to a FilterType Enum, and we need to update our Opt struct to hold it. Wed like to resize based on command line input constrained to one of these types.
Naively we could implement the following:</p>
<pre><code class="language-rust ignore no_run">use std::env;

struct Opt {
    input_path: String,
    output_path: String,
    scale_filter: FilterType,
}

fn options() -&gt; Option&lt;Opt&gt; {
    let filter_string = env::args().nth(3)?;

    //we actually match on a as_ref borrow of the String
    let filter = match filter_string.as_ref() {
        &quot;nearest&quot; =&gt; FilterType::Nearest,
        &quot;triangle&quot; =&gt; FilterType::Triangle,
        &quot;catmullrom&quot; =&gt; FilterType::CatmullRom,
        &quot;gaussian&quot; =&gt; FilterType::Gaussian,
        &quot;lanczos3&quot; =&gt; FilterType::Lanczos3,
        _ =&gt; panic!(&quot;uhh I don’t know that filter&quot;),
    };

    Some(Opt {
        input_path: env::args().nth(1)?,
        output_path: env::args().nth(2)?,
        scale_filter: filter,
    })
}

fn main() {
    let options = options().unwrap();
    println!(&quot;{}&quot;, options);
}
</code></pre>
<p>Which is totally workable but we can do one better, we can even write traits for enums which would be a clever solution to this problem. Lets abstract all that matching code into a trait. </p>
<p>Heres a trait definition:</p>
<pre><code class="language-rust ignore no_run">trait FilterString {
    fn from_str(input: String) -&gt; Option&lt;FilterType&gt;;
}
</code></pre>
<p>and the usage</p>
<pre><code class="language-rust ignore no_run">fn options() -&gt; Option&lt;Opt&gt; {
    let filter_string = env::args().nth(3)?;

    Some(Opt {
        input_path: env::args().nth(1)?,
        output_path: env::args().nth(2)?,
        scale_filter: FilterType::from_str(filter_string)?,
    })
}
</code></pre>
<p>Now finish out the the FilterString impl to make all this work</p>
<h1><a class="header" href="#enum-playground" id="enum-playground">enum playground</a></h1>
<p>You've started to aqaint yourself with enums in the error handling playground, but theres so much more it is worth spending some more time in the enum playground here to get your mind around how powerful the <a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html">pattern syntax</a> is.
TODO change this stolen example from https://doc.rust-lang.org/book/ch06-02-match.html</p>
<pre><pre class="playpen"><code class="language-rust">enum UsState {
    Alabama,
    Alaska,
}

//enums can contain any other type
enum Coin {
    Penny,
    Nickel(u32),
    Dime(String),
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    //you can match on any combination of your enum
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel(date) if date &lt; 1920 =&gt; 50,
        Coin::Nickel(date) if date &gt;= 1920 =&gt; 5,
        Coin::Dime(ref text) if text == &quot;scratched&quot; =&gt; 5,
        Coin::Dime(text) =&gt; {
            println!(&quot;{}&quot;, text);
            10
        }
        Coin::Quarter(UsState::Alaska) =&gt; {
            println!(&quot;State quarter from Alaska&quot;);
            25
        }
        Coin::Quarter(_state) =&gt; {
            println!(&quot;State quarter from elsewhere&quot;);
            25
        }
        //matches are exaustive, so if you don't cover all your use cases you need a catch all
        _ =&gt; 5,
    }
}

fn main() {
    println!(&quot;{}&quot;, value_in_cents(Coin::Quarter(UsState::Alabama)));
    println!(&quot;{}&quot;, value_in_cents(Coin::Dime(String::from(&quot;scratched&quot;))));
    println!(&quot;{}&quot;, value_in_cents(Coin::Dime(String::from(&quot;A+&quot;))));
    println!(&quot;{}&quot;, value_in_cents(Coin::Nickel(1921)));
    println!(&quot;{}&quot;, value_in_cents(Coin::Nickel(2000)));

    match 94 as u32 {
        1 | 2 =&gt; println!(&quot;one or two&quot;),
        3...4 =&gt; println!(&quot;three or four&quot;),
        11 =&gt; println!(&quot;11&quot;),
        12..=44 =&gt; println!(&quot;12 to 44 inclusive&quot;),
        _ =&gt; println!(&quot;The rest&quot;),
    }
}
</code></pre></pre>
<h1><a class="header" href="#todo" id="todo">todo</a></h1>
<h1><a class="header" href="#todo-1" id="todo-1">todo</a></h1>
<h1><a class="header" href="#control-structures" id="control-structures">Control Structures</a></h1>
<p>So you want a branch, eh? Rust will give you most of the familiar tools, and a few improved tools.</p>
<h2><a class="header" href="#if" id="if">If</a></h2>
<p>Notice, there are no required parentheses around the predicate (the compiler will gently warn you if you unnecessarily put them there). Comparison operators are nearly identical with C/C++.</p>
<p><a href="https://doc.rust-lang.org/book/appendix-02-operators.html">Rust operator reference</a></p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    if 1 + 1 == 2 {
        println!(&quot;It's true!&quot;);
    } else if 1 + 1 == 3 {
        println!(&quot;This world is quite odd...&quot;);
    } else {
        println!(&quot;What has the world come to?&quot;);
    }
}
</code></pre></pre>
<h3><a class="header" href="#if-is-an-expression" id="if-is-an-expression">If is an expression!</a></h3>
<p>Rust differs from C/C++ in that <code>if</code>, and other control flow structures, are also expressions that evaluate to a value. For example, the below <code>if</code> statement conditionally returns one of two strings. Notice that there are no semicolons after the return values, just like function return values.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    println!(&quot;The world is {}&quot;,
        if 1 + 1 == 2 {
            &quot;sane&quot;
        } else {
            &quot;insance&quot;
        });
}
</code></pre></pre>
<p>This <code>if</code> expression behaves much like the ternary operator in C/C++, but also allows you to have multiple <code>else if</code> predicates without nesting.</p>
<p>Control flow statements in Rust evaluate to a value, even if you are not using that value. If you end a branch with <code>;</code>, the return value will be <code>()</code>, the same as a function without a specified return value. Therefore, all the possible evaluations of the control structure need to return the same type. For example, the below code will not compile.</p>
<pre><code class="language-rust editable ignore">fn main() {
    if 1 + 1 == 2 {
        println!(&quot;The world is sane.&quot;);
    } else {
        5
    }
}
</code></pre>
<p>It's quite common in Rust to see functions that look like below. The return value of the function is the evaluated value of the if expression.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn square_if_over_10(i: i32) -&gt; i32 {
    if i &gt; 10 {
        i * i
    } else {
        i
    }
}
#}</code></pre></pre>
<h2><a class="header" href="#loop" id="loop">Loop</a></h2>
<p>Rust provides an unconditional loop construct, equivalent to <code>while (true) { }</code> in C/C++. The loop can be broken with <code>break</code> or execution can skip to the next iteration with <code>continue</code>. Unlike C/C++ loops, and just like Rust <code>if</code> statements, loops evaluate to a value as well.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let mut i = 2;
    let biggest = loop {
        if i &gt; 50 {
            break i / 2;
        }
        i *= 2;
    };
    println!(&quot;The biggest power of 2 less than 50 is {}&quot;, biggest);
}
</code></pre></pre>
<p>Just like in the <code>if</code> statements above, <code>break;</code> evaluates to the type <code>()</code>, but <code>break 5;</code> evaluates to an integer type.</p>
<h2><a class="header" href="#while" id="while">While</a></h2>
<p>Rust's while loop looks familiar, minus the parentheses around the predicate.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let mut i = 2;
    while i &lt; 50 {
        i *= 2;
    }
    println!(&quot;The biggest power of 2 less than 50 is {}&quot;, i / 2);
}
</code></pre></pre>
<h2><a class="header" href="#for" id="for">For?</a></h2>
<p>Those above contrived loop examples seem like perfect cases for a for loop right? Well, <code>for</code> is one of the places that Rust takes a familar control flow construct and completely rethinks how it should work. The below example might look more similar to Python:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    for i in 0..10 {
        println!(&quot;{}&quot;, i);
    }
}
</code></pre></pre>
<p>There's a good reason they look similar too! Much like Python, iterators are use all over the place. You won't find the familiar <code>for ( ; ; ) {}</code> construct, but don't worry; Rust's iterators are vastly more powerful, and safe. The next section takes us on a deep dive into iterators.</p>
<h1><a class="header" href="#iterators" id="iterators">Iterators</a></h1>
<p>Iterators are one of the most powerful features in Rust! They are also a gateway drug to functional programming.</p>
<p>The last example from the control flow section used a simple iterator, called a <code>Range</code> (similar to `range() in Python).</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    for i in 0..10 {
        println!(&quot;{}&quot;, i);
    }
}
</code></pre></pre>
<h2><a class="header" href="#combinators" id="combinators">Combinators</a></h2>
<p>The Rust standard library provides a large selection of combinators for use with iterators. Here's a whirlwind tour of a few important ones! You can find a full list in the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">documentation for the Iterator trait</a>.</p>
<p>The <code>map</code> method takes a closure to apply on each iterated element. It's the equivalent of running a given function on each element in the iterator and generating a new iterator of the return values.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    for i in (0..10).map(|i| i * 2) {
        println!(&quot;{}&quot;, i);
    }
}
</code></pre></pre>
<p>The <code>filter</code> method skips values that don't pass a predicate.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    for (i, j) in (1..10).map(|i| (i, i * 3)).filter(|(i, j)| i % 2 == 0) {
        println!(&quot;{} tripled is even: {}&quot;, i, j);
    }
}
</code></pre></pre>
<p><code>flat_map</code> iterates through iterators and concatenates them one after the other, or &quot;flattens&quot; them.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    for i in (1..5).flat_map(|i| 0..i) {
        println!(&quot;{}&quot;, i);
    }
}
</code></pre></pre>
<p><code>fold</code> combines all the values from an iterator, pairwise, starting with an initial value.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn factorial(n: i32) -&gt; i32 {
    (1..n).fold(n, |x, y| x * y)
}

fn main() {
    println!(&quot;5! = {}&quot;, factorial(5));
}
</code></pre></pre>
<p>If you want even more combinators, make sure to check out the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">docs</a>. And, if you want even more combinators, checkout the <a href="https://docs.rs/itertools/0.8.0/itertools/">itertools</a> crate!</p>
<h2><a class="header" href="#enumeration-combinator" id="enumeration-combinator">Enumeration combinator</a></h2>
<p>Sometimes, you miss your familar C-style for loop with its convenient access to the index; but don't run away yet, Rust has the <code>enumerate()</code> combinator for just this problem. The Iterator trait provides a combinator, called <code>enumerate</code> just for this purpose (very similar to Python's <code>enumerate()</code>).</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    for (index, value) in (100..110).enumerate() {
        println!(&quot;{}: {}&quot;, index, value);
    }
}
</code></pre></pre>
<p>You might have noticed in the above example that <code>enumerate</code> changed the iterator elements from integers to tuples (which is why we use <code>for (index, value) ...</code>). When you chain iterators together, you can modify the type of the iterator element as you go.</p>
<p>It's common to see code that keeps an index or other book-keeping info along with the value of interest in a tuple:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    for (index, value) in (100..110)
        .enumerate()
        .map(|(i, v)| (i, v * 10))
    {
        println!(&quot;{}: {}&quot;, index, value);
    }
}
</code></pre></pre>
<h2><a class="header" href="#more-complex-iterators-with-changing-element-type" id="more-complex-iterators-with-changing-element-type">More complex iterators with changing element type</a></h2>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    for (i, j, k) in (100..110) // type is usize
        .enumerate() // type is now (usize, usize)
        .map(|(i, j)| j * i) // type is now usize
        .map(|v| (v, v * 10, 0)) // type is now (usize, usize, usize)
    {
        println!(&quot;{}, {}, {}&quot;, i, j, k);
    }
}
</code></pre></pre>
<h1><a class="header" href="#todo-2" id="todo-2">todo</a></h1>
<h1><a class="header" href="#todo-3" id="todo-3">todo</a></h1>
<h1><a class="header" href="#todo-4" id="todo-4">todo</a></h1>
<h1><a class="header" href="#todo-5" id="todo-5">todo</a></h1>
<h1><a class="header" href="#todo-6" id="todo-6">todo</a></h1>
<h1><a class="header" href="#todo-7" id="todo-7">todo</a></h1>
<h1><a class="header" href="#todo-8" id="todo-8">todo</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
